#include "historyentry.h"
#include "formulahelper.h"
#include "generic_msgformatter.h"

/**
 * @brief HistoryEntry::HistoryEntry
 * @param idx index
 * @param u_id user id
 * @param ts QDateTime: timestamp of the new entry
 * @param cmd the associated command text, not the source
 * @param ty the type (read, monitor, alert)
 * @param _host the associated host
 */
HistoryEntry::HistoryEntry(int idx, int u_id, const QDateTime &ts,
                           const QString &cmd, const QString &ty,
                           const QString &_host)
{
    index = idx;
    user_id = u_id;
    datetime = ts;
    command = cmd;
    type = ty;
    host = _host;
    is_active = false;
    chat_id = -1;
}

/**
 * @brief HistoryEntry::HistoryEntry constructor version 2, without timestamp and index
 *
 * index is set to -1
 * timestamp is generated by QDateTime::currentDateTime
 *
 * @param u_id user id
 * @param cmd the associated command text, not the source
 * @param ty the type (read, monitor, alert)
 * @param _host the associated host
 */
HistoryEntry::HistoryEntry(int u_id, const QString &cmd, const QString &typ,
                           const QString &_host)
{
    user_id = u_id;
    command = cmd;
    type = typ;
    host = _host;
    is_active = false;
    datetime = QDateTime::currentDateTime();
    chat_id = -1;
    index = -1;
}

HistoryEntry::HistoryEntry()
{
    index = -1;
    user_id = -1;
    is_active = false;
}

bool HistoryEntry::isValid() const
{
    return user_id > -1 || datetime.isValid() || !command.isEmpty();
}

bool HistoryEntry::hasChatId() const {
    return chat_id > -1;
}

// user_id,chat_id,name,type,formula,host,start_dt
void HistoryEntry::fromDbProc(int u_id, int chatid, const QString& nam, const QString& typ,
                              const QString& hos,
                              const QDateTime& dt)
{
    user_id = u_id;
    chat_id = chatid;
    command = nam;
    type = typ;
    host = hos;
    datetime = dt;
    index = -1;
}

QString HistoryEntry::formatEntry_msg(int idx, int ttl, bool is_bookmark) const
{
    QString msg;
    // 1. type + source [+formula if not empty]
    msg += QString::number(idx+1) + ". "; // numbered list
    QString cmd = command;
    cmd = FormulaHelper().escape(cmd);
    msg += "<i>" + cmd + "</i>";

    // if bookmark add remove link
    is_bookmark ? msg += QString("   /XB%1\n").arg(index) : msg += "\n";

    // 2. if monitor or alert, print stop date and make link to restart if
    //    no more active
    if(type == "monitor" || type == "alert") {
        if(is_active) {
            QDateTime stop = datetime.addSecs(ttl);
            msg += "<b>active</b> until ";
            msg += "<i>" + GenMsgFormatter().timeRepr(stop) + "</i>";
        }
        else {
             msg += "inactive since " + GenMsgFormatter().timeRepr(stop_datetime);
        }

        // stop active monitor by link command
        if(is_active && index > -1)
            msg += QString(" stop [/X%1]").arg(index);

        msg += "\n";
        if(!is_active) {
            msg += QString("/%1%2 (<i>restart %1").arg(type).arg(index);
            hasHost() ? msg += "[" + host + "]</i>)" : msg += "</i>)";
        }
    }
    else { // one shot read: print date and time
        msg += "<i>" +  GenMsgFormatter().timeRepr(datetime) + "</i>\n";
        msg += "/read" + QString::number(index);
        if(!host.isEmpty())
            msg += " (" + host + ")";
    }
    msg+="\n\n";

    return msg;
}

QString HistoryEntry::toCommand() const
{
    QString s;
    if(user_id > -1) {
        s = command;
    }
    return s;
}

bool HistoryEntry::hasHost() const
{
    return !host.isEmpty();
}
